{"ast":null,"code":"/*!\n  * PhotoSwipe Lightbox 5.2.7 - https://photoswipe.com\n  * (c) 2022 Dmytro Semenov\n  */\n\n/** @typedef {import(\"../photoswipe\").Point} Point */\n\n/** @typedef {undefined | null | false | '' | 0} Falsy */\n\n/** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */\n\n/**\r\n * @template {HTMLElementTagName | Falsy} [T=\"div\"]\r\n * @template {Node | undefined} [NodeToAppendElementTo=undefined]\r\n * @param {string=} className\r\n * @param {T=} [tagName]\r\n * @param {NodeToAppendElementTo=} appendToEl\r\n * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}\r\n */\nfunction createElement(className, tagName, appendToEl) {\n  const el = document.createElement(tagName || 'div');\n\n  if (className) {\n    el.className = className;\n  }\n\n  if (appendToEl) {\n    appendToEl.appendChild(el);\n  } // @ts-expect-error\n\n\n  return el;\n}\n/**\r\n * Get transform string\r\n *\r\n * @param {number} x\r\n * @param {number=} y\r\n * @param {number=} scale\r\n */\n\n\nfunction toTransformString(x, y, scale) {\n  let propValue = 'translate3d(' + x + 'px,' + (y || 0) + 'px' + ',0)';\n\n  if (scale !== undefined) {\n    propValue += ' scale3d(' + scale + ',' + scale + ',1)';\n  }\n\n  return propValue;\n}\n/**\r\n * Apply width and height CSS properties to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string | number} w\r\n * @param {string | number} h\r\n */\n\n\nfunction setWidthHeight(el, w, h) {\n  el.style.width = typeof w === 'number' ? w + 'px' : w;\n  el.style.height = typeof h === 'number' ? h + 'px' : h;\n}\n/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */\n\n/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */\n\n\nconst LOAD_STATE = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  LOADED: 'loaded',\n  ERROR: 'error'\n};\n/**\r\n * Check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {MouseEvent | KeyboardEvent} e\r\n */\n\nfunction specialKeyUsed(e) {\n  if (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {\n    return true;\n  }\n}\n/**\r\n * Parse `gallery` or `children` options.\r\n *\r\n * @param {HTMLElement | NodeListOf<HTMLElement> | string} option\r\n * @param {string=} legacySelector\r\n * @param {HTMLElement | Document} [parent]\r\n * @returns HTMLElement[]\r\n */\n\n\nfunction getElementsFromOption(option, legacySelector, parent = document) {\n  /** @type {HTMLElement[]} */\n  let elements = [];\n\n  if (option instanceof Element) {\n    elements = [option];\n  } else if (option instanceof NodeList || Array.isArray(option)) {\n    elements = Array.from(option);\n  } else {\n    const selector = typeof option === 'string' ? option : legacySelector;\n\n    if (selector) {\n      elements = Array.from(parent.querySelectorAll(selector));\n    }\n  }\n\n  return elements;\n}\n/**\r\n * Check if variable is PhotoSwipe class\r\n *\r\n * @param {any} fn\r\n */\n\n\nfunction isPswpClass(fn) {\n  return typeof fn === 'function' && fn.prototype && fn.prototype.goTo;\n}\n/** @typedef {import(\"../lightbox/lightbox\").default} PhotoSwipeLightbox */\n\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import(\"../photoswipe\").DataSource} DataSource */\n\n/** @typedef {import(\"../ui/ui-element\").UIElementData} UIElementData */\n\n/** @typedef {import(\"../slide/content\").default} ContentDefault */\n\n/** @typedef {import(\"../slide/slide\").default} Slide */\n\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\n\n/** @typedef {import(\"../slide/zoom-level\").default} ZoomLevel */\n\n/** @typedef {import(\"../slide/get-thumb-bounds\").Bounds} Bounds */\n\n/**\r\n * Allow adding an arbitrary props to the Content\r\n * https://photoswipe.com/custom-content/#using-webp-image-format\r\n * @typedef {ContentDefault & Record<string, any>} Content\r\n */\n\n/** @typedef {{ x?: number; y?: number }} Point */\n\n/**\r\n * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/\r\n *\r\n *\r\n * https://photoswipe.com/adding-ui-elements/\r\n *\r\n * @prop {undefined} uiRegister\r\n * @prop {{ data: UIElementData }} uiElementCreate\r\n *\r\n *\r\n * https://photoswipe.com/events/#initialization-events\r\n *\r\n * @prop {undefined} beforeOpen\r\n * @prop {undefined} firstUpdate\r\n * @prop {undefined} initialLayout\r\n * @prop {undefined} change\r\n * @prop {undefined} afterInit\r\n * @prop {undefined} bindEvents\r\n *\r\n *\r\n * https://photoswipe.com/events/#opening-or-closing-transition-events\r\n *\r\n * @prop {undefined} openingAnimationStart\r\n * @prop {undefined} openingAnimationEnd\r\n * @prop {undefined} closingAnimationStart\r\n * @prop {undefined} closingAnimationEnd\r\n *\r\n *\r\n * https://photoswipe.com/events/#closing-events\r\n *\r\n * @prop {undefined} close\r\n * @prop {undefined} destroy\r\n *\r\n *\r\n * https://photoswipe.com/events/#pointer-and-gesture-events\r\n *\r\n * @prop {{ originalEvent: PointerEvent }} pointerDown\r\n * @prop {{ originalEvent: PointerEvent }} pointerMove\r\n * @prop {{ originalEvent: PointerEvent }} pointerUp\r\n * @prop {{ bgOpacity: number }} pinchClose can be default prevented\r\n * @prop {{ panY: number }} verticalDrag can be default prevented\r\n *\r\n *\r\n * https://photoswipe.com/events/#slide-content-events\r\n *\r\n * @prop {{ content: Content }} contentInit\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented\r\n * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete\r\n * @prop {{ content: Content; slide: Slide }} loadError\r\n * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented\r\n * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange\r\n * @prop {{ content: Content }} contentLazyLoad can be default prevented\r\n * @prop {{ content: Content }} contentAppend can be default prevented\r\n * @prop {{ content: Content }} contentActivate can be default prevented\r\n * @prop {{ content: Content }} contentDeactivate can be default prevented\r\n * @prop {{ content: Content }} contentRemove can be default prevented\r\n * @prop {{ content: Content }} contentDestroy can be default prevented\r\n *\r\n *\r\n * undocumented\r\n *\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented\r\n *\r\n * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented\r\n * @prop {{ x: number; dragging: boolean }} moveMainScroll\r\n * @prop {{ slide: Slide }} firstZoomPan\r\n * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData\r\n * @prop {undefined} beforeResize\r\n * @prop {undefined} resize\r\n * @prop {undefined} viewportSize\r\n * @prop {undefined} updateScrollOffset\r\n * @prop {{ slide: Slide }} slideInit\r\n * @prop {{ slide: Slide }} afterSetContent\r\n * @prop {{ slide: Slide }} slideLoad\r\n * @prop {{ slide: Slide }} appendHeavy can be default prevented\r\n * @prop {{ slide: Slide }} appendHeavyContent\r\n * @prop {{ slide: Slide }} slideActivate\r\n * @prop {{ slide: Slide }} slideDeactivate\r\n * @prop {{ slide: Slide }} slideDestroy\r\n * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo\r\n * @prop {{ slide: Slide }} zoomPanUpdate\r\n * @prop {{ slide: Slide }} initialZoomPan\r\n * @prop {{ slide: Slide }} calcSlideSize\r\n * @prop {undefined} resolutionChanged\r\n * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented\r\n * @prop {{ content: Content }} contentAppendImage can be default prevented\r\n * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented\r\n * @prop {undefined} lazyLoad\r\n * @prop {{ slide: Slide }} calcBounds\r\n * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate\r\n *\r\n *\r\n * legacy\r\n *\r\n * @prop {undefined} init\r\n * @prop {undefined} initialZoomIn\r\n * @prop {undefined} initialZoomOut\r\n * @prop {undefined} initialZoomInEnd\r\n * @prop {undefined} initialZoomOutEnd\r\n * @prop {{ dataSource: DataSource, numItems: number }} numItems\r\n * @prop {{ itemData: SlideData; index: number }} itemData\r\n * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds\r\n */\n\n/**\r\n * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/\r\n *\r\n * @prop {(numItems: number, dataSource: DataSource) => number} numItems\r\n * Modify the total amount of slides. Example on Data sources page.\r\n * https://photoswipe.com/filters/#numitems\r\n *\r\n * @prop {(itemData: SlideData, index: number) => SlideData} itemData\r\n * Modify slide item data. Example on Data sources page.\r\n * https://photoswipe.com/filters/#itemdata\r\n *\r\n * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData\r\n * Modify item data when it's parsed from DOM element. Example on Data sources page.\r\n * https://photoswipe.com/filters/#domitemdata\r\n *\r\n * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex\r\n * Modify clicked gallery item index.\r\n * https://photoswipe.com/filters/#clickedindex\r\n *\r\n * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc\r\n * Modify placeholder image source.\r\n * https://photoswipe.com/filters/#placeholdersrc\r\n *\r\n * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading\r\n * Modify if the content is currently loading.\r\n * https://photoswipe.com/filters/#iscontentloading\r\n *\r\n * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable\r\n * Modify if the content can be zoomed.\r\n * https://photoswipe.com/filters/#iscontentzoomable\r\n *\r\n * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder\r\n * Modify if the placeholder should be used for the content.\r\n * https://photoswipe.com/filters/#usecontentplaceholder\r\n *\r\n * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder\r\n * Modify if the placeholder should be kept after the content is loaded.\r\n * https://photoswipe.com/filters/#iskeepingplaceholder\r\n *\r\n *\r\n * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement\r\n * Modify an element when the content has error state (for example, if image cannot be loaded).\r\n * https://photoswipe.com/filters/#contenterrorelement\r\n *\r\n * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement\r\n * Modify a UI element that's being created.\r\n * https://photoswipe.com/filters/#uielement\r\n *\r\n * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl\r\n * Modify the thubmnail element from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbel\r\n *\r\n * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds\r\n * Modify the thubmnail bounds from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbbounds\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeFiltersMap} T\r\n * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>\r\n */\n\n/**\r\n * Base PhotoSwipe event object\r\n *\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n */\n\n\nclass PhotoSwipeEvent {\n  /**\r\n   * @param {T} type\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   */\n  constructor(type, details) {\n    this.type = type;\n\n    if (details) {\n      Object.assign(this, details);\n    }\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n}\n/**\r\n * PhotoSwipe base class that can listen and dispatch for events.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js\r\n */\n\n\nclass Eventable {\n  constructor() {\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}\r\n     */\n    this._listeners = {};\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}\r\n     */\n\n    this._filters = {};\n    /** @type {PhotoSwipe=} */\n\n    this.pswp = undefined;\n    /** @type {PhotoSwipeOptions} */\n\n    this.options = undefined;\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   * @param {number} priority\r\n   */\n\n\n  addFilter(name, fn, priority = 100) {\n    if (!this._filters[name]) {\n      this._filters[name] = [];\n    }\n\n    this._filters[name].push({\n      fn,\n      priority\n    });\n\n    this._filters[name].sort((f1, f2) => f1.priority - f2.priority);\n\n    if (this.pswp) {\n      this.pswp.addFilter(name, fn, priority);\n    }\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   */\n\n\n  removeFilter(name, fn) {\n    if (this._filters[name]) {\n      // @ts-expect-error\n      this._filters[name] = this._filters[name].filter(filter => filter.fn !== fn);\n    }\n\n    if (this.pswp) {\n      this.pswp.removeFilter(name, fn);\n    }\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args\r\n   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}\r\n   */\n\n\n  applyFilters(name, ...args) {\n    if (this._filters[name]) {\n      this._filters[name].forEach(filter => {\n        // @ts-expect-error\n        args[0] = filter.fn.apply(this, args);\n      });\n    }\n\n    return args[0];\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\n\n\n  on(name, fn) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n\n    this._listeners[name].push(fn); // When binding events to lightbox,\n    // also bind events to PhotoSwipe Core,\n    // if it's open.\n\n\n    if (this.pswp) {\n      this.pswp.on(name, fn);\n    }\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\n\n\n  off(name, fn) {\n    if (this._listeners[name]) {\n      // @ts-expect-error\n      this._listeners[name] = this._listeners[name].filter(listener => fn !== listener);\n    }\n\n    if (this.pswp) {\n      this.pswp.off(name, fn);\n    }\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   * @returns {AugmentedEvent<T>}\r\n   */\n\n\n  dispatch(name, details) {\n    if (this.pswp) {\n      return this.pswp.dispatch(name, details);\n    }\n\n    const event =\n    /** @type {AugmentedEvent<T>} */\n    new PhotoSwipeEvent(name, details);\n\n    if (!this._listeners) {\n      return event;\n    }\n\n    if (this._listeners[name]) {\n      this._listeners[name].forEach(listener => {\n        listener.call(this, event);\n      });\n    }\n\n    return event;\n  }\n\n}\n\nclass Placeholder {\n  /**\r\n   * @param {string | false} imageSrc\r\n   * @param {HTMLElement} container\r\n   */\n  constructor(imageSrc, container) {\n    // Create placeholder\n    // (stretched thumbnail or simple div behind the main image)\n    this.element = createElement('pswp__img pswp__img--placeholder', imageSrc ? 'img' : '', container);\n\n    if (imageSrc) {\n      /** @type {HTMLImageElement} */\n      this.element.decoding = 'async';\n      /** @type {HTMLImageElement} */\n\n      this.element.alt = '';\n      /** @type {HTMLImageElement} */\n\n      this.element.src = imageSrc;\n      this.element.setAttribute('role', 'presentation');\n    }\n\n    this.element.setAttribute('aria-hiden', 'true');\n  }\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\n\n\n  setDisplayedSize(width, height) {\n    if (!this.element) {\n      return;\n    }\n\n    if (this.element.tagName === 'IMG') {\n      // Use transform scale() to modify img placeholder size\n      // (instead of changing width/height directly).\n      // This helps with performance, specifically in iOS15 Safari.\n      setWidthHeight(this.element, 250, 'auto');\n      this.element.style.transformOrigin = '0 0';\n      this.element.style.transform = toTransformString(0, 0, width / 250);\n    } else {\n      setWidthHeight(this.element, width, height);\n    }\n  }\n\n  destroy() {\n    if (this.element.parentNode) {\n      this.element.remove();\n    }\n\n    this.element = null;\n  }\n\n}\n/** @typedef {import(\"./slide\").default} Slide */\n\n/** @typedef {import(\"./slide\").SlideData} SlideData */\n\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../util/util\").LoadState} LoadState */\n\n\nclass Content {\n  /**\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n   * @param {number} index\r\n   */\n  constructor(itemData, instance, index) {\n    this.instance = instance;\n    this.data = itemData;\n    this.index = index;\n    /** @type {HTMLImageElement | HTMLDivElement} */\n\n    this.element = undefined;\n    this.width = Number(this.data.w) || Number(this.data.width) || 0;\n    this.height = Number(this.data.h) || Number(this.data.height) || 0;\n    this.isAttached = false;\n    this.hasSlide = false;\n    /** @type {LoadState} */\n\n    this.state = LOAD_STATE.IDLE;\n\n    if (this.data.type) {\n      this.type = this.data.type;\n    } else if (this.data.src) {\n      this.type = 'image';\n    } else {\n      this.type = 'html';\n    }\n\n    this.instance.dispatch('contentInit', {\n      content: this\n    });\n  }\n\n  removePlaceholder() {\n    if (this.placeholder && !this.keepPlaceholder()) {\n      // With delay, as image might be loaded, but not rendered\n      setTimeout(() => {\n        if (this.placeholder) {\n          this.placeholder.destroy();\n          this.placeholder = null;\n        }\n      }, 500);\n    }\n  }\n  /**\r\n   * Preload content\r\n   *\r\n   * @param {boolean=} isLazy\r\n   * @param {boolean=} reload\r\n   */\n\n\n  load(isLazy, reload) {\n    if (!this.placeholder && this.slide && this.usePlaceholder()) {\n      // use   -based placeholder only for the first slide,\n      // as rendering (even small stretched thumbnail) is an expensive operation\n      const placeholderSrc = this.instance.applyFilters('placeholderSrc', this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : false, this);\n      this.placeholder = new Placeholder(placeholderSrc, this.slide.container);\n    }\n\n    if (this.element && !reload) {\n      return;\n    }\n\n    if (this.instance.dispatch('contentLoad', {\n      content: this,\n      isLazy\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.isImageContent()) {\n      this.loadImage(isLazy);\n    } else {\n      this.element = createElement('pswp__content');\n      this.element.innerHTML = this.data.html || '';\n    }\n\n    if (reload && this.slide) {\n      this.slide.updateContentSize(true);\n    }\n  }\n  /**\r\n   * Preload image\r\n   *\r\n   * @param {boolean} isLazy\r\n   */\n\n\n  loadImage(isLazy) {\n    const imageElement = createElement('pswp__img', 'img');\n    this.element = imageElement;\n\n    if (this.instance.dispatch('contentLoadImage', {\n      content: this,\n      isLazy\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.data.srcset) {\n      imageElement.srcset = this.data.srcset;\n    }\n\n    imageElement.src = this.data.src;\n    imageElement.alt = this.data.alt || '';\n    this.state = LOAD_STATE.LOADING;\n\n    if (imageElement.complete) {\n      this.onLoaded();\n    } else {\n      imageElement.onload = () => {\n        this.onLoaded();\n      };\n\n      imageElement.onerror = () => {\n        this.onError();\n      };\n    }\n  }\n  /**\r\n   * Assign slide to content\r\n   *\r\n   * @param {Slide} slide\r\n   */\n\n\n  setSlide(slide) {\n    this.slide = slide;\n    this.hasSlide = true;\n    this.instance = slide.pswp; // todo: do we need to unset slide?\n  }\n  /**\r\n   * Content load success handler\r\n   */\n\n\n  onLoaded() {\n    this.state = LOAD_STATE.LOADED;\n\n    if (this.slide) {\n      this.instance.dispatch('loadComplete', {\n        slide: this.slide,\n        content: this\n      }); // if content is reloaded\n\n      if (this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode) {\n        this.slide.container.innerHTML = '';\n        this.append();\n        this.slide.updateContentSize(true);\n      }\n    }\n  }\n  /**\r\n   * Content load error handler\r\n   */\n\n\n  onError() {\n    this.state = LOAD_STATE.ERROR;\n\n    if (this.slide) {\n      this.displayError();\n      this.instance.dispatch('loadComplete', {\n        slide: this.slide,\n        isError: true,\n        content: this\n      });\n      this.instance.dispatch('loadError', {\n        slide: this.slide,\n        content: this\n      });\n    }\n  }\n  /**\r\n   * @returns {Boolean} If the content is currently loading\r\n   */\n\n\n  isLoading() {\n    return this.instance.applyFilters('isContentLoading', this.state === LOAD_STATE.LOADING, this);\n  }\n\n  isError() {\n    return this.state === LOAD_STATE.ERROR;\n  }\n  /**\r\n   * @returns {boolean} If the content is image\r\n   */\n\n\n  isImageContent() {\n    return this.type === 'image';\n  }\n  /**\r\n   * Update content size\r\n   *\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\n\n\n  setDisplayedSize(width, height) {\n    if (!this.element) {\n      return;\n    }\n\n    if (this.placeholder) {\n      this.placeholder.setDisplayedSize(width, height);\n    } // eslint-disable-next-line max-len\n\n\n    if (this.instance.dispatch('contentResize', {\n      content: this,\n      width,\n      height\n    }).defaultPrevented) {\n      return;\n    }\n\n    setWidthHeight(this.element, width, height);\n\n    if (this.isImageContent() && !this.isError()) {\n      const image =\n      /** @type HTMLImageElement */\n      this.element; // Handle srcset sizes attribute.\n      //\n      // Never lower quality, if it was increased previously.\n      // Chrome does this automatically, Firefox and Safari do not,\n      // so we store largest used size in dataset.\n\n      if (image.srcset // eslint-disable-next-line max-len\n      && (!image.dataset.largestUsedSize || width > parseInt(image.dataset.largestUsedSize, 10))) {\n        image.sizes = width + 'px';\n        image.dataset.largestUsedSize = String(width);\n      }\n\n      if (this.slide) {\n        // eslint-disable-next-line max-len\n        this.instance.dispatch('imageSizeChange', {\n          slide: this.slide,\n          width,\n          height,\n          content: this\n        });\n      }\n    }\n  }\n  /**\r\n   * @returns {boolean} If the content can be zoomed\r\n   */\n\n\n  isZoomable() {\n    return this.instance.applyFilters('isContentZoomable', this.isImageContent() && this.state !== LOAD_STATE.ERROR, this);\n  }\n  /**\r\n   * @returns {boolean} If content should use a placeholder (from msrc by default)\r\n   */\n\n\n  usePlaceholder() {\n    return this.instance.applyFilters('useContentPlaceholder', this.isImageContent(), this);\n  }\n  /**\r\n   * Preload content with lazy-loading param\r\n   */\n\n\n  lazyLoad() {\n    if (this.instance.dispatch('contentLazyLoad', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    this.load(true);\n  }\n  /**\r\n   * @returns {boolean} If placeholder should be kept after content is loaded\r\n   */\n\n\n  keepPlaceholder() {\n    return this.instance.applyFilters('isKeepingPlaceholder', this.isLoading(), this);\n  }\n  /**\r\n   * Destroy the content\r\n   */\n\n\n  destroy() {\n    this.hasSlide = false;\n    this.slide = null;\n\n    if (this.instance.dispatch('contentDestroy', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    this.remove();\n\n    if (this.isImageContent() && this.element) {\n      this.element.onload = null;\n      this.element.onerror = null;\n      this.element = null;\n    }\n  }\n  /**\r\n   * Display error message\r\n   */\n\n\n  displayError() {\n    if (this.slide) {\n      /** @type {HTMLElement} */\n      let errorMsgEl = createElement('pswp__error-msg');\n      errorMsgEl.innerText = this.instance.options.errorMsg;\n      errorMsgEl = this.instance.applyFilters('contentErrorElement', errorMsgEl, this);\n      this.element = createElement('pswp__content pswp__error-msg-container');\n      this.element.appendChild(errorMsgEl);\n      this.slide.container.innerHTML = '';\n      this.slide.container.appendChild(this.element);\n      this.slide.updateContentSize(true);\n      this.removePlaceholder();\n    }\n  }\n  /**\r\n   * Append the content\r\n   */\n\n\n  append() {\n    this.isAttached = true;\n\n    if (this.state === LOAD_STATE.ERROR) {\n      this.displayError();\n      return;\n    }\n\n    if (this.instance.dispatch('contentAppend', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.isImageContent()) {\n      // Use decode() on nearby slides\n      //\n      // Nearby slide images are in DOM and not hidden via display:none.\n      // However, they are placed offscreen (to the left and right side).\n      //\n      // Some browsers do not composite the image until it's actually visible,\n      // using decode() helps.\n      //\n      // You might ask \"why dont you just decode() and then append all images\",\n      // that's because I want to show image before it's fully loaded,\n      // as browser can render parts of image while it is loading.\n      if (this.slide && !this.slide.isActive && 'decode' in this.element) {\n        this.isDecoding = true; // Make sure that we start decoding on the next frame\n\n        requestAnimationFrame(() => {\n          // element might change\n          if (this.element && this.element.tagName === 'IMG') {\n            /** @type {HTMLImageElement} */\n            this.element.decode().then(() => {\n              this.isDecoding = false;\n              requestAnimationFrame(() => {\n                this.appendImage();\n              });\n            }).catch(() => {\n              this.isDecoding = false;\n            });\n          }\n        });\n      } else {\n        if (this.placeholder // eslint-disable-next-line max-len\n        && (this.state === LOAD_STATE.LOADED ||\n        /** @type {LoadState} */\n        this.state === LOAD_STATE.ERROR)) {\n          this.removePlaceholder();\n        }\n\n        this.appendImage();\n      }\n    } else if (this.element && !this.element.parentNode) {\n      this.slide.container.appendChild(this.element);\n    }\n  }\n  /**\r\n   * Activate the slide,\r\n   * active slide is generally the current one,\r\n   * meaning the user can see it.\r\n   */\n\n\n  activate() {\n    if (this.instance.dispatch('contentActivate', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.slide) {\n      if (this.isImageContent() && this.isDecoding) {\n        // add image to slide when it becomes active,\n        // even if it's not finished decoding\n        this.appendImage();\n      } else if (this.isError()) {\n        this.load(false, true); // try to reload\n      }\n    }\n  }\n  /**\r\n   * Deactivate the content\r\n   */\n\n\n  deactivate() {\n    this.instance.dispatch('contentDeactivate', {\n      content: this\n    });\n  }\n  /**\r\n   * Remove the content from DOM\r\n   */\n\n\n  remove() {\n    this.isAttached = false;\n\n    if (this.instance.dispatch('contentRemove', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.element && this.element.parentNode) {\n      this.element.remove();\n    }\n  }\n  /**\r\n   * Append the image content to slide container\r\n   */\n\n\n  appendImage() {\n    if (!this.isAttached) {\n      return;\n    }\n\n    if (this.instance.dispatch('contentAppendImage', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    } // ensure that element exists and is not already appended\n\n\n    if (this.slide && this.element && !this.element.parentNode) {\n      this.slide.container.appendChild(this.element);\n\n      if (this.placeholder && (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR)) {\n        this.removePlaceholder();\n      }\n    }\n  }\n\n}\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\n\n/**\r\n * PhotoSwipe base class that can retrieve data about every slide.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox\r\n */\n\n\nclass PhotoSwipeBase extends Eventable {\n  /**\r\n   * Get total number of slides\r\n   *\r\n   * @returns {number}\r\n   */\n  getNumItems() {\n    let numItems;\n    const {\n      dataSource\n    } = this.options;\n\n    if (!dataSource) {\n      numItems = 0;\n    } else if ('length' in dataSource) {\n      // may be an array or just object with length property\n      numItems = dataSource.length;\n    } else if ('gallery' in dataSource) {\n      // query DOM elements\n      if (!dataSource.items) {\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\n      }\n\n      if (dataSource.items) {\n        numItems = dataSource.items.length;\n      }\n    } // legacy event, before filters were introduced\n\n\n    const event = this.dispatch('numItems', {\n      dataSource,\n      numItems\n    });\n    return this.applyFilters('numItems', event.numItems, dataSource);\n  }\n  /**\r\n   * @param {SlideData} slideData\r\n   * @param {number} index\r\n   */\n\n\n  createContentFromData(slideData, index) {\n    // @ts-expect-error\n    return new Content(slideData, this, index);\n  }\n  /**\r\n   * Get item data by index.\r\n   *\r\n   * \"item data\" should contain normalized information that PhotoSwipe needs to generate a slide.\r\n   * For example, it may contain properties like\r\n   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.\r\n   *\r\n   * @param {number} index\r\n   */\n\n\n  getItemData(index) {\n    const {\n      dataSource\n    } = this.options;\n    let dataSourceItem;\n\n    if (Array.isArray(dataSource)) {\n      // Datasource is an array of elements\n      dataSourceItem = dataSource[index];\n    } else if (dataSource && dataSource.gallery) {\n      // dataSource has gallery property,\n      // thus it was created by Lightbox, based on\n      // gallery and children options\n      // query DOM elements\n      if (!dataSource.items) {\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\n      }\n\n      dataSourceItem = dataSource.items[index];\n    }\n\n    let itemData = dataSourceItem;\n\n    if (itemData instanceof Element) {\n      itemData = this._domElementToItemData(itemData);\n    } // Dispatching the itemData event,\n    // it's a legacy verion before filters were introduced\n\n\n    const event = this.dispatch('itemData', {\n      itemData: itemData || {},\n      index\n    });\n    return this.applyFilters('itemData', event.itemData, index);\n  }\n  /**\r\n   * Get array of gallery DOM elements,\r\n   * based on childSelector and gallery element.\r\n   *\r\n   * @param {HTMLElement} galleryElement\r\n   */\n\n\n  _getGalleryDOMElements(galleryElement) {\n    if (this.options.children || this.options.childSelector) {\n      return getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [];\n    }\n\n    return [galleryElement];\n  }\n  /**\r\n   * Converts DOM element to item data object.\r\n   *\r\n   * @param {HTMLElement} element DOM element\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  _domElementToItemData(element) {\n    /** @type {SlideData} */\n    const itemData = {\n      element\n    }; // eslint-disable-next-line max-len\n\n    const linkEl =\n    /** @type {HTMLAnchorElement} */\n    element.tagName === 'A' ? element : element.querySelector('a');\n\n    if (linkEl) {\n      // src comes from data-pswp-src attribute,\n      // if it's empty link href is used\n      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;\n\n      if (linkEl.dataset.pswpSrcset) {\n        itemData.srcset = linkEl.dataset.pswpSrcset;\n      }\n\n      itemData.width = parseInt(linkEl.dataset.pswpWidth, 10);\n      itemData.height = parseInt(linkEl.dataset.pswpHeight, 10); // support legacy w & h properties\n\n      itemData.w = itemData.width;\n      itemData.h = itemData.height;\n\n      if (linkEl.dataset.pswpType) {\n        itemData.type = linkEl.dataset.pswpType;\n      }\n\n      const thumbnailEl = element.querySelector('img');\n\n      if (thumbnailEl) {\n        // msrc is URL to placeholder image that's displayed before large image is loaded\n        // by default it's displayed only for the first slide\n        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;\n        itemData.alt = thumbnailEl.getAttribute('alt');\n      }\n\n      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {\n        itemData.thumbCropped = true;\n      }\n    }\n\n    return this.applyFilters('domItemData', itemData, element, linkEl);\n  }\n\n}\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\n\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {PhotoSwipe} pswp\r\n */\n\n\nfunction getViewportSize(options, pswp) {\n  if (options.getViewportSizeFn) {\n    const newViewportSize = options.getViewportSizeFn(options, pswp);\n\n    if (newViewportSize) {\n      return newViewportSize;\n    }\n  }\n\n  return {\n    x: document.documentElement.clientWidth,\n    // TODO: height on mobile is very incosistent due to toolbar\n    // find a way to improve this\n    //\n    // document.documentElement.clientHeight - doesn't seem to work well\n    y: window.innerHeight\n  };\n}\n/**\r\n * Parses padding option.\r\n * Supported formats:\r\n *\r\n * // Object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // A function that returns the object\r\n * paddingFn: (viewportSize, itemData, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // Legacy variant\r\n * paddingLeft: 0,\r\n * paddingRight: 0,\r\n * paddingTop: 0,\r\n * paddingBottom: 0,\r\n *\r\n * @param {'left' | 'top' | 'bottom' | 'right'} prop\r\n * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {number} index Slide index\r\n * @returns {number}\r\n */\n\n\nfunction parsePaddingOption(prop, options, viewportSize, itemData, index) {\n  /** @type {number} */\n  let paddingValue;\n\n  if (options.paddingFn) {\n    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];\n  } else if (options.padding) {\n    paddingValue = options.padding[prop];\n  } else {\n    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1); // @ts-expect-error\n\n    if (options[legacyPropName]) {\n      // @ts-expect-error\n      paddingValue = options[legacyPropName];\n    }\n  }\n\n  return paddingValue || 0;\n}\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {{ x?: number; y?: number }} viewportSize\r\n * @param {SlideData} itemData\r\n * @param {number} index\r\n */\n\n\nfunction getPanAreaSize(options, viewportSize, itemData, index) {\n  return {\n    x: viewportSize.x - parsePaddingOption('left', options, viewportSize, itemData, index) - parsePaddingOption('right', options, viewportSize, itemData, index),\n    y: viewportSize.y - parsePaddingOption('top', options, viewportSize, itemData, index) - parsePaddingOption('bottom', options, viewportSize, itemData, index)\n  };\n}\n\nconst MAX_IMAGE_WIDTH = 4000;\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\n\n/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */\n\n/**\r\n * Calculates zoom levels for specific slide.\r\n * Depends on viewport size and image size.\r\n */\n\nclass ZoomLevel {\n  /**\r\n   * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {number} index Slide index\r\n   * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet\r\n   */\n  constructor(options, itemData, index, pswp) {\n    this.pswp = pswp;\n    this.options = options;\n    this.itemData = itemData;\n    this.index = index;\n  }\n  /**\r\n   * Calculate initial, secondary and maximum zoom level for the specified slide.\r\n   *\r\n   * It should be called when either image or viewport size changes.\r\n   *\r\n   * @param {number} maxWidth\r\n   * @param {number} maxHeight\r\n   * @param {{ x?: number; y?: number }} panAreaSize\r\n   */\n\n\n  update(maxWidth, maxHeight, panAreaSize) {\n    this.elementSize = {\n      x: maxWidth,\n      y: maxHeight\n    };\n    this.panAreaSize = panAreaSize;\n    const hRatio = this.panAreaSize.x / this.elementSize.x;\n    const vRatio = this.panAreaSize.y / this.elementSize.y;\n    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);\n    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio); // zoom.vFill defines zoom level of the image\n    // when it has 100% of viewport vertical space (height)\n\n    this.vFill = Math.min(1, vRatio);\n    this.initial = this._getInitial();\n    this.secondary = this._getSecondary();\n    this.max = Math.max(this.initial, this.secondary, this._getMax());\n    this.min = Math.min(this.fit, this.initial, this.secondary);\n\n    if (this.pswp) {\n      this.pswp.dispatch('zoomLevelsUpdate', {\n        zoomLevels: this,\n        slideData: this.itemData\n      });\n    }\n  }\n  /**\r\n   * Parses user-defined zoom option.\r\n   *\r\n   * @private\r\n   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)\r\n   */\n\n\n  _parseZoomLevelOption(optionPrefix) {\n    // eslint-disable-next-line max-len\n    const optionName =\n    /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */\n    optionPrefix + 'ZoomLevel';\n    const optionValue = this.options[optionName];\n\n    if (!optionValue) {\n      return;\n    }\n\n    if (typeof optionValue === 'function') {\n      return optionValue(this);\n    }\n\n    if (optionValue === 'fill') {\n      return this.fill;\n    }\n\n    if (optionValue === 'fit') {\n      return this.fit;\n    }\n\n    return Number(optionValue);\n  }\n  /**\r\n   * Get zoom level to which image will be zoomed after double-tap gesture,\r\n   * or when user clicks on zoom icon,\r\n   * or mouse-click on image itself.\r\n   * If you return 1 image will be zoomed to its original size.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getSecondary() {\n    let currZoomLevel = this._parseZoomLevelOption('secondary');\n\n    if (currZoomLevel) {\n      return currZoomLevel;\n    } // 3x of \"fit\" state, but not larger than original\n\n\n    currZoomLevel = Math.min(1, this.fit * 3);\n\n    if (currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {\n      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;\n    }\n\n    return currZoomLevel;\n  }\n  /**\r\n   * Get initial image zoom level.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getInitial() {\n    return this._parseZoomLevelOption('initial') || this.fit;\n  }\n  /**\r\n   * Maximum zoom level when user zooms\r\n   * via zoom/pinch gesture,\r\n   * via cmd/ctrl-wheel or via trackpad.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getMax() {\n    const currZoomLevel = this._parseZoomLevelOption('max');\n\n    if (currZoomLevel) {\n      return currZoomLevel;\n    } // max zoom level is x4 from \"fit state\",\n    // used for zoom gesture and ctrl/trackpad zoom\n\n\n    return Math.max(1, this.fit * 4);\n  }\n\n}\n/**\r\n * Lazy-load an image\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox\r\n * @param {number} index\r\n * @returns Image that is being decoded or false.\r\n */\n\n\nfunction lazyLoadData(itemData, instance, index) {\n  // src/slide/content/content.js\n  const content = instance.createContentFromData(itemData, index);\n\n  if (!content || !content.lazyLoad) {\n    return;\n  }\n\n  const {\n    options\n  } = instance; // We need to know dimensions of the image to preload it,\n  // as it might use srcset and we need to define sizes\n  // @ts-expect-error should provide pswp instance?\n\n  const viewportSize = instance.viewportSize || getViewportSize(options, instance);\n  const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);\n  const zoomLevel = new ZoomLevel(options, itemData, -1);\n  zoomLevel.update(content.width, content.height, panAreaSize);\n  content.lazyLoad();\n  content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial));\n  return content;\n}\n/**\r\n * Lazy-loads specific slide.\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * By default it loads image based on viewport size and initial zoom level.\r\n *\r\n * @param {number} index Slide index\r\n * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance\r\n */\n\n\nfunction lazyLoadSlide(index, instance) {\n  const itemData = instance.getItemData(index);\n\n  if (instance.dispatch('lazyLoadSlide', {\n    index,\n    itemData\n  }).defaultPrevented) {\n    return;\n  }\n\n  return lazyLoadData(itemData, instance, index);\n}\n/**\r\n * @template T\r\n * @typedef {import(\"../types\").Type<T>} Type<T>\r\n */\n\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\n\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import(\"../photoswipe\").DataSource} DataSource */\n\n/** @typedef {import(\"../slide/content\").default} Content */\n\n/** @typedef {import(\"../core/eventable\").PhotoSwipeEventsMap} PhotoSwipeEventsMap */\n\n/** @typedef {import(\"../core/eventable\").PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */\n\n/**\r\n * @template T\r\n * @typedef {import(\"../core/eventable\").EventCallback<T>} EventCallback<T>\r\n */\n\n/**\r\n * PhotoSwipe Lightbox\r\n *\r\n * - If user has unsupported browser it falls back to default browser action (just opens URL)\r\n * - Binds click event to links that should open PhotoSwipe\r\n * - parses DOM strcture for PhotoSwipe (retrieves large image URLs and sizes)\r\n * - Initializes PhotoSwipe\r\n *\r\n *\r\n * Loader options use the same object as PhotoSwipe, and supports such options:\r\n *\r\n * gallery - Element | Element[] | NodeList | string selector for the gallery element\r\n * children - Element | Element[] | NodeList | string selector for the gallery children\r\n *\r\n */\n\n\nclass PhotoSwipeLightbox extends PhotoSwipeBase {\n  /**\r\n   * @param {PhotoSwipeOptions} options\r\n   */\n  constructor(options) {\n    super();\n    /** @type {PhotoSwipeOptions} */\n\n    this.options = options || {};\n    this._uid = 0;\n  }\n  /**\r\n   * Initialize lightbox, should be called only once.\r\n   * It's not included in the main constructor, so you may bind events before it.\r\n   */\n\n\n  init() {\n    this.onThumbnailsClick = this.onThumbnailsClick.bind(this); // Bind click events to each gallery\n\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector).forEach(galleryElement => {\n      galleryElement.addEventListener('click', this.onThumbnailsClick, false);\n    });\n  }\n  /**\r\n   * @param {MouseEvent} e\r\n   */\n\n\n  onThumbnailsClick(e) {\n    // Exit and allow default browser action if:\n    if (specialKeyUsed(e) // ... if clicked with a special key (ctrl/cmd...)\n    || window.pswp // ... if PhotoSwipe is already open\n    || window.navigator.onLine === false) {\n      // ... if offline\n      return;\n    } // If both clientX and clientY are 0 or not defined,\n    // the event is likely triggered by keyboard,\n    // so we do not pass the initialPoint\n    //\n    // Note that some screen readers emulate the mouse position,\n    // so it's not ideal way to detect them.\n    //\n\n\n    let initialPoint = {\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (!initialPoint.x && !initialPoint.y) {\n      initialPoint = null;\n    }\n\n    let clickedIndex = this.getClickedIndex(e);\n    clickedIndex = this.applyFilters('clickedIndex', clickedIndex, e, this);\n    const dataSource = {\n      gallery:\n      /** @type {HTMLElement} */\n      e.currentTarget\n    };\n\n    if (clickedIndex >= 0) {\n      e.preventDefault();\n      this.loadAndOpen(clickedIndex, dataSource, initialPoint);\n    }\n  }\n  /**\r\n   * Get index of gallery item that was clicked.\r\n   *\r\n   * @param {MouseEvent} e click event\r\n   */\n\n\n  getClickedIndex(e) {\n    // legacy option\n    if (this.options.getClickedIndexFn) {\n      return this.options.getClickedIndexFn.call(this, e);\n    }\n\n    const clickedTarget =\n    /** @type {HTMLElement} */\n    e.target;\n    const childElements = getElementsFromOption(this.options.children, this.options.childSelector,\n    /** @type {HTMLElement} */\n    e.currentTarget);\n    const clickedChildIndex = childElements.findIndex(child => child === clickedTarget || child.contains(clickedTarget));\n\n    if (clickedChildIndex !== -1) {\n      return clickedChildIndex;\n    } else if (this.options.children || this.options.childSelector) {\n      // click wasn't on a child element\n      return -1;\n    } // There is only one item (which is the gallery)\n\n\n    return 0;\n  }\n  /**\r\n   * Load and open PhotoSwipe\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource=} dataSource\r\n   * @param {{ x?: number; y?: number }} [initialPoint]\r\n   */\n\n\n  loadAndOpen(index, dataSource, initialPoint) {\n    // Check if the gallery is already open\n    if (window.pswp) {\n      return false;\n    } // set initial index\n\n\n    this.options.index = index; // define options for PhotoSwipe constructor\n\n    this.options.initialPointerPos = initialPoint;\n    this.shouldOpen = true;\n    this.preload(index, dataSource);\n    return true;\n  }\n  /**\r\n   * Load the main module and the slide content by index\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource=} dataSource\r\n   */\n\n\n  preload(index, dataSource) {\n    const {\n      options\n    } = this;\n\n    if (dataSource) {\n      options.dataSource = dataSource;\n    } // Add the main module\n\n    /** @type {Promise<Type<PhotoSwipe>>[]} */\n\n\n    const promiseArray = [];\n    const pswpModuleType = typeof options.pswpModule;\n\n    if (isPswpClass(options.pswpModule)) {\n      promiseArray.push(Promise.resolve(\n      /** @type {Type<PhotoSwipe>} */\n      options.pswpModule));\n    } else if (pswpModuleType === 'string') {\n      throw new Error('pswpModule as string is no longer supported');\n    } else if (pswpModuleType === 'function') {\n      promiseArray.push(\n      /** @type {() => Promise<Type<PhotoSwipe>>} */\n      options.pswpModule());\n    } else {\n      throw new Error('pswpModule is not valid');\n    } // Add custom-defined promise, if any\n\n\n    if (typeof options.openPromise === 'function') {\n      // allow developers to perform some task before opening\n      promiseArray.push(options.openPromise());\n    }\n\n    if (options.preloadFirstSlide !== false && index >= 0) {\n      this._preloadedContent = lazyLoadSlide(index, this);\n    } // Wait till all promises resolve and open PhotoSwipe\n\n\n    const uid = ++this._uid;\n    Promise.all(promiseArray).then(iterableModules => {\n      if (this.shouldOpen) {\n        const mainModule = iterableModules[0];\n\n        this._openPhotoswipe(mainModule, uid);\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @param {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} module\r\n   * @param {number} uid\r\n   */\n\n\n  _openPhotoswipe(module, uid) {\n    // Cancel opening if UID doesn't match the current one\n    // (if user clicked on another gallery item before current was loaded).\n    //\n    // Or if shouldOpen flag is set to false\n    // (developer may modify it via public API)\n    if (uid !== this._uid && this.shouldOpen) {\n      return;\n    }\n\n    this.shouldOpen = false; // PhotoSwipe is already open\n\n    if (window.pswp) {\n      return;\n    }\n    /**\r\n     * Pass data to PhotoSwipe and open init\r\n     *\r\n     * @type {PhotoSwipe}\r\n     */\n\n\n    const pswp = typeof module === 'object' ? new module.default(this.options) // eslint-disable-line\n    : new module(this.options); // eslint-disable-line\n\n    this.pswp = pswp;\n    window.pswp = pswp; // map listeners from Lightbox to PhotoSwipe Core\n\n    /** @type {(keyof PhotoSwipeEventsMap)[]} */\n\n    Object.keys(this._listeners).forEach(name => {\n      this._listeners[name].forEach(fn => {\n        pswp.on(name,\n        /** @type {EventCallback<typeof name>} */\n        fn);\n      });\n    }); // same with filters\n\n    /** @type {(keyof PhotoSwipeFiltersMap)[]} */\n\n    Object.keys(this._filters).forEach(name => {\n      this._filters[name].forEach(filter => {\n        pswp.addFilter(name, filter.fn, filter.priority);\n      });\n    });\n\n    if (this._preloadedContent) {\n      pswp.contentLoader.addToCache(this._preloadedContent);\n      this._preloadedContent = null;\n    }\n\n    pswp.on('destroy', () => {\n      // clean up public variables\n      this.pswp = null;\n      window.pswp = null;\n    });\n    pswp.init();\n  }\n  /**\r\n   * Unbinds all events, closes PhotoSwipe if it's open.\r\n   */\n\n\n  destroy() {\n    if (this.pswp) {\n      this.pswp.destroy();\n    }\n\n    this.shouldOpen = false;\n    this._listeners = null;\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector).forEach(galleryElement => {\n      galleryElement.removeEventListener('click', this.onThumbnailsClick, false);\n    });\n  }\n\n}\n\nexport { PhotoSwipeLightbox as default };","map":{"version":3,"sources":["/Users/salamonszilard/work/szilardsalamon/szilardsalamon/node_modules/photoswipe/dist/photoswipe-lightbox.esm.js"],"names":["createElement","className","tagName","appendToEl","el","document","appendChild","toTransformString","x","y","scale","propValue","undefined","setWidthHeight","w","h","style","width","height","LOAD_STATE","IDLE","LOADING","LOADED","ERROR","specialKeyUsed","e","which","ctrlKey","metaKey","altKey","shiftKey","getElementsFromOption","option","legacySelector","parent","elements","Element","NodeList","Array","isArray","from","selector","querySelectorAll","isPswpClass","fn","prototype","goTo","PhotoSwipeEvent","constructor","type","details","Object","assign","preventDefault","defaultPrevented","Eventable","_listeners","_filters","pswp","options","addFilter","name","priority","push","sort","f1","f2","removeFilter","filter","applyFilters","args","forEach","apply","on","off","listener","dispatch","event","call","Placeholder","imageSrc","container","element","decoding","alt","src","setAttribute","setDisplayedSize","transformOrigin","transform","destroy","parentNode","remove","Content","itemData","instance","index","data","Number","isAttached","hasSlide","state","content","removePlaceholder","placeholder","keepPlaceholder","setTimeout","load","isLazy","reload","slide","usePlaceholder","placeholderSrc","msrc","isFirstSlide","isImageContent","loadImage","innerHTML","html","updateContentSize","imageElement","srcset","complete","onLoaded","onload","onerror","onError","setSlide","isActive","heavyAppended","append","displayError","isError","isLoading","image","dataset","largestUsedSize","parseInt","sizes","String","isZoomable","lazyLoad","errorMsgEl","innerText","errorMsg","isDecoding","requestAnimationFrame","decode","then","appendImage","catch","activate","deactivate","PhotoSwipeBase","getNumItems","numItems","dataSource","length","items","_getGalleryDOMElements","gallery","createContentFromData","slideData","getItemData","dataSourceItem","_domElementToItemData","galleryElement","children","childSelector","linkEl","querySelector","pswpSrc","href","pswpSrcset","pswpWidth","pswpHeight","pswpType","thumbnailEl","currentSrc","getAttribute","pswpCropped","cropped","thumbCropped","getViewportSize","getViewportSizeFn","newViewportSize","documentElement","clientWidth","window","innerHeight","parsePaddingOption","prop","viewportSize","paddingValue","paddingFn","padding","legacyPropName","toUpperCase","slice","getPanAreaSize","MAX_IMAGE_WIDTH","ZoomLevel","update","maxWidth","maxHeight","panAreaSize","elementSize","hRatio","vRatio","fit","Math","min","fill","vFill","initial","_getInitial","secondary","_getSecondary","max","_getMax","zoomLevels","_parseZoomLevelOption","optionPrefix","optionName","optionValue","currZoomLevel","lazyLoadData","zoomLevel","ceil","lazyLoadSlide","PhotoSwipeLightbox","_uid","init","onThumbnailsClick","bind","gallerySelector","addEventListener","navigator","onLine","initialPoint","clientX","clientY","clickedIndex","getClickedIndex","currentTarget","loadAndOpen","getClickedIndexFn","clickedTarget","target","childElements","clickedChildIndex","findIndex","child","contains","initialPointerPos","shouldOpen","preload","promiseArray","pswpModuleType","pswpModule","Promise","resolve","Error","openPromise","preloadFirstSlide","_preloadedContent","uid","all","iterableModules","mainModule","_openPhotoswipe","module","default","keys","contentLoader","addToCache","removeEventListener"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,eAAN,CAAsB;AACpB;AACF;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACzB,SAAKD,IAAL,GAAYA,IAAZ;;AACA,QAAIC,OAAJ,EAAa;AACXC,MAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBF,OAApB;AACD;AACF;;AAEDG,EAAAA,cAAc,GAAG;AACf,SAAKC,gBAAL,GAAwB,IAAxB;AACD;;AAdmB;AAiBtB;AACA;AACA;AACA;;;AACA,MAAMC,SAAN,CAAgB;AACdP,EAAAA,WAAW,GAAG;AACZ;AACJ;AACA;AACI,SAAKQ,UAAL,GAAkB,EAAlB;AAEA;AACJ;AACA;;AACI,SAAKC,QAAL,GAAgB,EAAhB;AAEA;;AACA,SAAKC,IAAL,GAAY9C,SAAZ;AAEA;;AACA,SAAK+C,OAAL,GAAe/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","sourcesContent":["/*!\n  * PhotoSwipe Lightbox 5.2.7 - https://photoswipe.com\n  * (c) 2022 Dmytro Semenov\n  */\n/** @typedef {import(\"../photoswipe\").Point} Point */\r\n\r\n/** @typedef {undefined | null | false | '' | 0} Falsy */\r\n/** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */\r\n\r\n/**\r\n * @template {HTMLElementTagName | Falsy} [T=\"div\"]\r\n * @template {Node | undefined} [NodeToAppendElementTo=undefined]\r\n * @param {string=} className\r\n * @param {T=} [tagName]\r\n * @param {NodeToAppendElementTo=} appendToEl\r\n * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}\r\n */\r\nfunction createElement(className, tagName, appendToEl) {\r\n  const el = document.createElement(tagName || 'div');\r\n  if (className) {\r\n    el.className = className;\r\n  }\r\n  if (appendToEl) {\r\n    appendToEl.appendChild(el);\r\n  }\r\n  // @ts-expect-error\r\n  return el;\r\n}\r\n\r\n/**\r\n * Get transform string\r\n *\r\n * @param {number} x\r\n * @param {number=} y\r\n * @param {number=} scale\r\n */\r\nfunction toTransformString(x, y, scale) {\r\n  let propValue = 'translate3d('\r\n    + x + 'px,' + (y || 0) + 'px'\r\n    + ',0)';\r\n\r\n  if (scale !== undefined) {\r\n    propValue += ' scale3d('\r\n      + scale + ',' + scale\r\n      + ',1)';\r\n  }\r\n\r\n  return propValue;\r\n}\r\n\r\n/**\r\n * Apply width and height CSS properties to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string | number} w\r\n * @param {string | number} h\r\n */\r\nfunction setWidthHeight(el, w, h) {\r\n  el.style.width = (typeof w === 'number') ? (w + 'px') : w;\r\n  el.style.height = (typeof h === 'number') ? (h + 'px') : h;\r\n}\r\n\r\n/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */\r\n/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */\r\nconst LOAD_STATE = {\r\n  IDLE: 'idle',\r\n  LOADING: 'loading',\r\n  LOADED: 'loaded',\r\n  ERROR: 'error',\r\n};\r\n\r\n\r\n/**\r\n * Check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {MouseEvent | KeyboardEvent} e\r\n */\r\nfunction specialKeyUsed(e) {\r\n  if (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Parse `gallery` or `children` options.\r\n *\r\n * @param {HTMLElement | NodeListOf<HTMLElement> | string} option\r\n * @param {string=} legacySelector\r\n * @param {HTMLElement | Document} [parent]\r\n * @returns HTMLElement[]\r\n */\r\nfunction getElementsFromOption(option, legacySelector, parent = document) {\r\n  /** @type {HTMLElement[]} */\r\n  let elements = [];\r\n\r\n  if (option instanceof Element) {\r\n    elements = [option];\r\n  } else if (option instanceof NodeList || Array.isArray(option)) {\r\n    elements = Array.from(option);\r\n  } else {\r\n    const selector = typeof option === 'string' ? option : legacySelector;\r\n    if (selector) {\r\n      elements = Array.from(parent.querySelectorAll(selector));\r\n    }\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\n/**\r\n * Check if variable is PhotoSwipe class\r\n *\r\n * @param {any} fn\r\n */\r\nfunction isPswpClass(fn) {\r\n  return typeof fn === 'function'\r\n    && fn.prototype\r\n    && fn.prototype.goTo;\r\n}\n\n/** @typedef {import(\"../lightbox/lightbox\").default} PhotoSwipeLightbox */\r\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import(\"../photoswipe\").DataSource} DataSource */\r\n/** @typedef {import(\"../ui/ui-element\").UIElementData} UIElementData */\r\n/** @typedef {import(\"../slide/content\").default} ContentDefault */\r\n/** @typedef {import(\"../slide/slide\").default} Slide */\r\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\r\n/** @typedef {import(\"../slide/zoom-level\").default} ZoomLevel */\r\n/** @typedef {import(\"../slide/get-thumb-bounds\").Bounds} Bounds */\r\n\r\n/**\r\n * Allow adding an arbitrary props to the Content\r\n * https://photoswipe.com/custom-content/#using-webp-image-format\r\n * @typedef {ContentDefault & Record<string, any>} Content\r\n */\r\n/** @typedef {{ x?: number; y?: number }} Point */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/\r\n *\r\n *\r\n * https://photoswipe.com/adding-ui-elements/\r\n *\r\n * @prop {undefined} uiRegister\r\n * @prop {{ data: UIElementData }} uiElementCreate\r\n *\r\n *\r\n * https://photoswipe.com/events/#initialization-events\r\n *\r\n * @prop {undefined} beforeOpen\r\n * @prop {undefined} firstUpdate\r\n * @prop {undefined} initialLayout\r\n * @prop {undefined} change\r\n * @prop {undefined} afterInit\r\n * @prop {undefined} bindEvents\r\n *\r\n *\r\n * https://photoswipe.com/events/#opening-or-closing-transition-events\r\n *\r\n * @prop {undefined} openingAnimationStart\r\n * @prop {undefined} openingAnimationEnd\r\n * @prop {undefined} closingAnimationStart\r\n * @prop {undefined} closingAnimationEnd\r\n *\r\n *\r\n * https://photoswipe.com/events/#closing-events\r\n *\r\n * @prop {undefined} close\r\n * @prop {undefined} destroy\r\n *\r\n *\r\n * https://photoswipe.com/events/#pointer-and-gesture-events\r\n *\r\n * @prop {{ originalEvent: PointerEvent }} pointerDown\r\n * @prop {{ originalEvent: PointerEvent }} pointerMove\r\n * @prop {{ originalEvent: PointerEvent }} pointerUp\r\n * @prop {{ bgOpacity: number }} pinchClose can be default prevented\r\n * @prop {{ panY: number }} verticalDrag can be default prevented\r\n *\r\n *\r\n * https://photoswipe.com/events/#slide-content-events\r\n *\r\n * @prop {{ content: Content }} contentInit\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented\r\n * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete\r\n * @prop {{ content: Content; slide: Slide }} loadError\r\n * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented\r\n * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange\r\n * @prop {{ content: Content }} contentLazyLoad can be default prevented\r\n * @prop {{ content: Content }} contentAppend can be default prevented\r\n * @prop {{ content: Content }} contentActivate can be default prevented\r\n * @prop {{ content: Content }} contentDeactivate can be default prevented\r\n * @prop {{ content: Content }} contentRemove can be default prevented\r\n * @prop {{ content: Content }} contentDestroy can be default prevented\r\n *\r\n *\r\n * undocumented\r\n *\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented\r\n *\r\n * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented\r\n * @prop {{ x: number; dragging: boolean }} moveMainScroll\r\n * @prop {{ slide: Slide }} firstZoomPan\r\n * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData\r\n * @prop {undefined} beforeResize\r\n * @prop {undefined} resize\r\n * @prop {undefined} viewportSize\r\n * @prop {undefined} updateScrollOffset\r\n * @prop {{ slide: Slide }} slideInit\r\n * @prop {{ slide: Slide }} afterSetContent\r\n * @prop {{ slide: Slide }} slideLoad\r\n * @prop {{ slide: Slide }} appendHeavy can be default prevented\r\n * @prop {{ slide: Slide }} appendHeavyContent\r\n * @prop {{ slide: Slide }} slideActivate\r\n * @prop {{ slide: Slide }} slideDeactivate\r\n * @prop {{ slide: Slide }} slideDestroy\r\n * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo\r\n * @prop {{ slide: Slide }} zoomPanUpdate\r\n * @prop {{ slide: Slide }} initialZoomPan\r\n * @prop {{ slide: Slide }} calcSlideSize\r\n * @prop {undefined} resolutionChanged\r\n * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented\r\n * @prop {{ content: Content }} contentAppendImage can be default prevented\r\n * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented\r\n * @prop {undefined} lazyLoad\r\n * @prop {{ slide: Slide }} calcBounds\r\n * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate\r\n *\r\n *\r\n * legacy\r\n *\r\n * @prop {undefined} init\r\n * @prop {undefined} initialZoomIn\r\n * @prop {undefined} initialZoomOut\r\n * @prop {undefined} initialZoomInEnd\r\n * @prop {undefined} initialZoomOutEnd\r\n * @prop {{ dataSource: DataSource, numItems: number }} numItems\r\n * @prop {{ itemData: SlideData; index: number }} itemData\r\n * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds\r\n */\r\n\r\n/**\r\n * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/\r\n *\r\n * @prop {(numItems: number, dataSource: DataSource) => number} numItems\r\n * Modify the total amount of slides. Example on Data sources page.\r\n * https://photoswipe.com/filters/#numitems\r\n *\r\n * @prop {(itemData: SlideData, index: number) => SlideData} itemData\r\n * Modify slide item data. Example on Data sources page.\r\n * https://photoswipe.com/filters/#itemdata\r\n *\r\n * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData\r\n * Modify item data when it's parsed from DOM element. Example on Data sources page.\r\n * https://photoswipe.com/filters/#domitemdata\r\n *\r\n * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex\r\n * Modify clicked gallery item index.\r\n * https://photoswipe.com/filters/#clickedindex\r\n *\r\n * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc\r\n * Modify placeholder image source.\r\n * https://photoswipe.com/filters/#placeholdersrc\r\n *\r\n * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading\r\n * Modify if the content is currently loading.\r\n * https://photoswipe.com/filters/#iscontentloading\r\n *\r\n * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable\r\n * Modify if the content can be zoomed.\r\n * https://photoswipe.com/filters/#iscontentzoomable\r\n *\r\n * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder\r\n * Modify if the placeholder should be used for the content.\r\n * https://photoswipe.com/filters/#usecontentplaceholder\r\n *\r\n * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder\r\n * Modify if the placeholder should be kept after the content is loaded.\r\n * https://photoswipe.com/filters/#iskeepingplaceholder\r\n *\r\n *\r\n * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement\r\n * Modify an element when the content has error state (for example, if image cannot be loaded).\r\n * https://photoswipe.com/filters/#contenterrorelement\r\n *\r\n * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement\r\n * Modify a UI element that's being created.\r\n * https://photoswipe.com/filters/#uielement\r\n *\r\n * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl\r\n * Modify the thubmnail element from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbel\r\n *\r\n * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds\r\n * Modify the thubmnail bounds from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbbounds\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeFiltersMap} T\r\n * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent\r\n */\r\n\r\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>\r\n */\r\n\r\n/**\r\n * Base PhotoSwipe event object\r\n *\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n */\r\nclass PhotoSwipeEvent {\r\n  /**\r\n   * @param {T} type\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   */\r\n  constructor(type, details) {\r\n    this.type = type;\r\n    if (details) {\r\n      Object.assign(this, details);\r\n    }\r\n  }\r\n\r\n  preventDefault() {\r\n    this.defaultPrevented = true;\r\n  }\r\n}\r\n\r\n/**\r\n * PhotoSwipe base class that can listen and dispatch for events.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js\r\n */\r\nclass Eventable {\r\n  constructor() {\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}\r\n     */\r\n    this._listeners = {};\r\n\r\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}\r\n     */\r\n    this._filters = {};\r\n\r\n    /** @type {PhotoSwipe=} */\r\n    this.pswp = undefined;\r\n\r\n    /** @type {PhotoSwipeOptions} */\r\n    this.options = undefined;\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   * @param {number} priority\r\n   */\r\n  addFilter(name, fn, priority = 100) {\r\n    if (!this._filters[name]) {\r\n      this._filters[name] = [];\r\n    }\r\n\r\n    this._filters[name].push({ fn, priority });\r\n    this._filters[name].sort((f1, f2) => f1.priority - f2.priority);\r\n\r\n    if (this.pswp) {\r\n      this.pswp.addFilter(name, fn, priority);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   */\r\n  removeFilter(name, fn) {\r\n    if (this._filters[name]) {\r\n      // @ts-expect-error\r\n      this._filters[name] = this._filters[name].filter(filter => (filter.fn !== fn));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.removeFilter(name, fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args\r\n   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}\r\n   */\r\n  applyFilters(name, ...args) {\r\n    if (this._filters[name]) {\r\n      this._filters[name].forEach((filter) => {\r\n        // @ts-expect-error\r\n        args[0] = filter.fn.apply(this, args);\r\n      });\r\n    }\r\n    return args[0];\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  on(name, fn) {\r\n    if (!this._listeners[name]) {\r\n      this._listeners[name] = [];\r\n    }\r\n    this._listeners[name].push(fn);\r\n\r\n    // When binding events to lightbox,\r\n    // also bind events to PhotoSwipe Core,\r\n    // if it's open.\r\n    if (this.pswp) {\r\n      this.pswp.on(name, fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\r\n  off(name, fn) {\r\n    if (this._listeners[name]) {\r\n      // @ts-expect-error\r\n      this._listeners[name] = this._listeners[name].filter(listener => (fn !== listener));\r\n    }\r\n\r\n    if (this.pswp) {\r\n      this.pswp.off(name, fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   * @returns {AugmentedEvent<T>}\r\n   */\r\n  dispatch(name, details) {\r\n    if (this.pswp) {\r\n      return this.pswp.dispatch(name, details);\r\n    }\r\n\r\n    const event = /** @type {AugmentedEvent<T>} */ (new PhotoSwipeEvent(name, details));\r\n\r\n    if (!this._listeners) {\r\n      return event;\r\n    }\r\n\r\n    if (this._listeners[name]) {\r\n      this._listeners[name].forEach((listener) => {\r\n        listener.call(this, event);\r\n      });\r\n    }\r\n\r\n    return event;\r\n  }\r\n}\n\nclass Placeholder {\r\n  /**\r\n   * @param {string | false} imageSrc\r\n   * @param {HTMLElement} container\r\n   */\r\n  constructor(imageSrc, container) {\r\n    // Create placeholder\r\n    // (stretched thumbnail or simple div behind the main image)\r\n    this.element = createElement(\r\n      'pswp__img pswp__img--placeholder',\r\n      imageSrc ? 'img' : '',\r\n      container\r\n    );\r\n\r\n    if (imageSrc) {\r\n      /** @type {HTMLImageElement} */\r\n      (this.element).decoding = 'async';\r\n      /** @type {HTMLImageElement} */\r\n      (this.element).alt = '';\r\n      /** @type {HTMLImageElement} */\r\n      (this.element).src = imageSrc;\r\n      this.element.setAttribute('role', 'presentation');\r\n    }\r\n\r\n    this.element.setAttribute('aria-hiden', 'true');\r\n  }\r\n\r\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.element.tagName === 'IMG') {\r\n      // Use transform scale() to modify img placeholder size\r\n      // (instead of changing width/height directly).\r\n      // This helps with performance, specifically in iOS15 Safari.\r\n      setWidthHeight(this.element, 250, 'auto');\r\n      this.element.style.transformOrigin = '0 0';\r\n      this.element.style.transform = toTransformString(0, 0, width / 250);\r\n    } else {\r\n      setWidthHeight(this.element, width, height);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    if (this.element.parentNode) {\r\n      this.element.remove();\r\n    }\r\n    this.element = null;\r\n  }\r\n}\n\n/** @typedef {import(\"./slide\").default} Slide */\r\n/** @typedef {import(\"./slide\").SlideData} SlideData */\r\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../util/util\").LoadState} LoadState */\r\n\r\nclass Content {\r\n  /**\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n   * @param {number} index\r\n   */\r\n  constructor(itemData, instance, index) {\r\n    this.instance = instance;\r\n    this.data = itemData;\r\n    this.index = index;\r\n\r\n    /** @type {HTMLImageElement | HTMLDivElement} */\r\n    this.element = undefined;\r\n\r\n    this.width = Number(this.data.w) || Number(this.data.width) || 0;\r\n    this.height = Number(this.data.h) || Number(this.data.height) || 0;\r\n\r\n    this.isAttached = false;\r\n    this.hasSlide = false;\r\n    /** @type {LoadState} */\r\n    this.state = LOAD_STATE.IDLE;\r\n\r\n    if (this.data.type) {\r\n      this.type = this.data.type;\r\n    } else if (this.data.src) {\r\n      this.type = 'image';\r\n    } else {\r\n      this.type = 'html';\r\n    }\r\n\r\n    this.instance.dispatch('contentInit', { content: this });\r\n  }\r\n\r\n  removePlaceholder() {\r\n    if (this.placeholder && !this.keepPlaceholder()) {\r\n      // With delay, as image might be loaded, but not rendered\r\n      setTimeout(() => {\r\n        if (this.placeholder) {\r\n          this.placeholder.destroy();\r\n          this.placeholder = null;\r\n        }\r\n      }, 500);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload content\r\n   *\r\n   * @param {boolean=} isLazy\r\n   * @param {boolean=} reload\r\n   */\r\n  load(isLazy, reload) {\r\n    if (!this.placeholder && this.slide && this.usePlaceholder()) {\r\n      // use   -based placeholder only for the first slide,\r\n      // as rendering (even small stretched thumbnail) is an expensive operation\r\n      const placeholderSrc = this.instance.applyFilters(\r\n        'placeholderSrc',\r\n        (this.data.msrc && this.slide.isFirstSlide) ? this.data.msrc : false,\r\n        this\r\n      );\r\n      this.placeholder = new Placeholder(\r\n        placeholderSrc,\r\n        this.slide.container\r\n      );\r\n    }\r\n\r\n    if (this.element && !reload) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentLoad', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent()) {\r\n      this.loadImage(isLazy);\r\n    } else {\r\n      this.element = createElement('pswp__content');\r\n      this.element.innerHTML = this.data.html || '';\r\n    }\r\n\r\n    if (reload && this.slide) {\r\n      this.slide.updateContentSize(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preload image\r\n   *\r\n   * @param {boolean} isLazy\r\n   */\r\n  loadImage(isLazy) {\r\n    const imageElement = createElement('pswp__img', 'img');\r\n    this.element = imageElement;\r\n\r\n    if (this.instance.dispatch('contentLoadImage', { content: this, isLazy }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.data.srcset) {\r\n      imageElement.srcset = this.data.srcset;\r\n    }\r\n\r\n    imageElement.src = this.data.src;\r\n\r\n    imageElement.alt = this.data.alt || '';\r\n\r\n    this.state = LOAD_STATE.LOADING;\r\n\r\n    if (imageElement.complete) {\r\n      this.onLoaded();\r\n    } else {\r\n      imageElement.onload = () => {\r\n        this.onLoaded();\r\n      };\r\n\r\n      imageElement.onerror = () => {\r\n        this.onError();\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assign slide to content\r\n   *\r\n   * @param {Slide} slide\r\n   */\r\n  setSlide(slide) {\r\n    this.slide = slide;\r\n    this.hasSlide = true;\r\n    this.instance = slide.pswp;\r\n\r\n    // todo: do we need to unset slide?\r\n  }\r\n\r\n  /**\r\n   * Content load success handler\r\n   */\r\n  onLoaded() {\r\n    this.state = LOAD_STATE.LOADED;\r\n\r\n    if (this.slide) {\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, content: this });\r\n\r\n      // if content is reloaded\r\n      if (this.slide.isActive\r\n          && this.slide.heavyAppended\r\n          && !this.element.parentNode) {\r\n        this.slide.container.innerHTML = '';\r\n        this.append();\r\n        this.slide.updateContentSize(true);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Content load error handler\r\n   */\r\n  onError() {\r\n    this.state = LOAD_STATE.ERROR;\r\n\r\n    if (this.slide) {\r\n      this.displayError();\r\n      this.instance.dispatch('loadComplete', { slide: this.slide, isError: true, content: this });\r\n      this.instance.dispatch('loadError', { slide: this.slide, content: this });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {Boolean} If the content is currently loading\r\n   */\r\n  isLoading() {\r\n    return this.instance.applyFilters(\r\n      'isContentLoading',\r\n      this.state === LOAD_STATE.LOADING,\r\n      this\r\n    );\r\n  }\r\n\r\n  isError() {\r\n    return this.state === LOAD_STATE.ERROR;\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content is image\r\n   */\r\n  isImageContent() {\r\n    return this.type === 'image';\r\n  }\r\n\r\n  /**\r\n   * Update content size\r\n   *\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\r\n  setDisplayedSize(width, height) {\r\n    if (!this.element) {\r\n      return;\r\n    }\r\n\r\n    if (this.placeholder) {\r\n      this.placeholder.setDisplayedSize(width, height);\r\n    }\r\n\r\n    // eslint-disable-next-line max-len\r\n    if (this.instance.dispatch('contentResize', { content: this, width, height }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    setWidthHeight(this.element, width, height);\r\n\r\n    if (this.isImageContent() && !this.isError()) {\r\n      const image = /** @type HTMLImageElement */ (this.element);\r\n\r\n      // Handle srcset sizes attribute.\r\n      //\r\n      // Never lower quality, if it was increased previously.\r\n      // Chrome does this automatically, Firefox and Safari do not,\r\n      // so we store largest used size in dataset.\r\n      if (image.srcset\r\n          // eslint-disable-next-line max-len\r\n          && (!image.dataset.largestUsedSize || width > parseInt(image.dataset.largestUsedSize, 10))) {\r\n        image.sizes = width + 'px';\r\n        image.dataset.largestUsedSize = String(width);\r\n      }\r\n\r\n      if (this.slide) {\r\n        // eslint-disable-next-line max-len\r\n        this.instance.dispatch('imageSizeChange', { slide: this.slide, width, height, content: this });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If the content can be zoomed\r\n   */\r\n  isZoomable() {\r\n    return this.instance.applyFilters(\r\n      'isContentZoomable',\r\n      this.isImageContent() && (this.state !== LOAD_STATE.ERROR),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If content should use a placeholder (from msrc by default)\r\n   */\r\n  usePlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'useContentPlaceholder',\r\n      this.isImageContent(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Preload content with lazy-loading param\r\n   */\r\n  lazyLoad() {\r\n    if (this.instance.dispatch('contentLazyLoad', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.load(true);\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} If placeholder should be kept after content is loaded\r\n   */\r\n  keepPlaceholder() {\r\n    return this.instance.applyFilters(\r\n      'isKeepingPlaceholder',\r\n      this.isLoading(),\r\n      this\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Destroy the content\r\n   */\r\n  destroy() {\r\n    this.hasSlide = false;\r\n    this.slide = null;\r\n\r\n    if (this.instance.dispatch('contentDestroy', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    this.remove();\r\n\r\n    if (this.isImageContent() && this.element) {\r\n      this.element.onload = null;\r\n      this.element.onerror = null;\r\n      this.element = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Display error message\r\n   */\r\n  displayError() {\r\n    if (this.slide) {\r\n      /** @type {HTMLElement} */\r\n      let errorMsgEl = createElement('pswp__error-msg');\r\n      errorMsgEl.innerText = this.instance.options.errorMsg;\r\n      errorMsgEl = this.instance.applyFilters(\r\n        'contentErrorElement',\r\n        errorMsgEl,\r\n        this\r\n      );\r\n      this.element = createElement('pswp__content pswp__error-msg-container');\r\n      this.element.appendChild(errorMsgEl);\r\n      this.slide.container.innerHTML = '';\r\n      this.slide.container.appendChild(this.element);\r\n      this.slide.updateContentSize(true);\r\n      this.removePlaceholder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the content\r\n   */\r\n  append() {\r\n    this.isAttached = true;\r\n\r\n    if (this.state === LOAD_STATE.ERROR) {\r\n      this.displayError();\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppend', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.isImageContent()) {\r\n      // Use decode() on nearby slides\r\n      //\r\n      // Nearby slide images are in DOM and not hidden via display:none.\r\n      // However, they are placed offscreen (to the left and right side).\r\n      //\r\n      // Some browsers do not composite the image until it's actually visible,\r\n      // using decode() helps.\r\n      //\r\n      // You might ask \"why dont you just decode() and then append all images\",\r\n      // that's because I want to show image before it's fully loaded,\r\n      // as browser can render parts of image while it is loading.\r\n      if (this.slide\r\n          && !this.slide.isActive\r\n          && ('decode' in this.element)) {\r\n        this.isDecoding = true;\r\n        // Make sure that we start decoding on the next frame\r\n        requestAnimationFrame(() => {\r\n          // element might change\r\n          if (this.element && this.element.tagName === 'IMG') {\r\n            /** @type {HTMLImageElement} */\r\n            (this.element).decode().then(() => {\r\n              this.isDecoding = false;\r\n              requestAnimationFrame(() => {\r\n                this.appendImage();\r\n              });\r\n            }).catch(() => {\r\n              this.isDecoding = false;\r\n            });\r\n          }\r\n        });\r\n      } else {\r\n        if (this.placeholder\r\n          // eslint-disable-next-line max-len\r\n          && (this.state === LOAD_STATE.LOADED || /** @type {LoadState} */ (this.state) === LOAD_STATE.ERROR)\r\n        ) {\r\n          this.removePlaceholder();\r\n        }\r\n        this.appendImage();\r\n      }\r\n    } else if (this.element && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate the slide,\r\n   * active slide is generally the current one,\r\n   * meaning the user can see it.\r\n   */\r\n  activate() {\r\n    if (this.instance.dispatch('contentActivate', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.slide) {\r\n      if (this.isImageContent() && this.isDecoding) {\r\n        // add image to slide when it becomes active,\r\n        // even if it's not finished decoding\r\n        this.appendImage();\r\n      } else if (this.isError()) {\r\n        this.load(false, true); // try to reload\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deactivate the content\r\n   */\r\n  deactivate() {\r\n    this.instance.dispatch('contentDeactivate', { content: this });\r\n  }\r\n\r\n\r\n  /**\r\n   * Remove the content from DOM\r\n   */\r\n  remove() {\r\n    this.isAttached = false;\r\n\r\n    if (this.instance.dispatch('contentRemove', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    if (this.element && this.element.parentNode) {\r\n      this.element.remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the image content to slide container\r\n   */\r\n  appendImage() {\r\n    if (!this.isAttached) {\r\n      return;\r\n    }\r\n\r\n    if (this.instance.dispatch('contentAppendImage', { content: this }).defaultPrevented) {\r\n      return;\r\n    }\r\n\r\n    // ensure that element exists and is not already appended\r\n    if (this.slide && this.element && !this.element.parentNode) {\r\n      this.slide.container.appendChild(this.element);\r\n\r\n      if (this.placeholder\r\n        && (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR)) {\r\n        this.removePlaceholder();\r\n      }\r\n    }\r\n  }\r\n}\n\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\r\n\r\n/**\r\n * PhotoSwipe base class that can retrieve data about every slide.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox\r\n */\r\nclass PhotoSwipeBase extends Eventable {\r\n  /**\r\n   * Get total number of slides\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getNumItems() {\r\n    let numItems;\r\n    const { dataSource } = this.options;\r\n    if (!dataSource) {\r\n      numItems = 0;\r\n    } else if ('length' in dataSource) {\r\n      // may be an array or just object with length property\r\n      numItems = dataSource.length;\r\n    } else if ('gallery' in dataSource) {\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      if (dataSource.items) {\r\n        numItems = dataSource.items.length;\r\n      }\r\n    }\r\n\r\n    // legacy event, before filters were introduced\r\n    const event = this.dispatch('numItems', {\r\n      dataSource,\r\n      numItems\r\n    });\r\n    return this.applyFilters('numItems', event.numItems, dataSource);\r\n  }\r\n\r\n  /**\r\n   * @param {SlideData} slideData\r\n   * @param {number} index\r\n   */\r\n  createContentFromData(slideData, index) {\r\n    // @ts-expect-error\r\n    return new Content(slideData, this, index);\r\n  }\r\n\r\n  /**\r\n   * Get item data by index.\r\n   *\r\n   * \"item data\" should contain normalized information that PhotoSwipe needs to generate a slide.\r\n   * For example, it may contain properties like\r\n   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.\r\n   *\r\n   * @param {number} index\r\n   */\r\n  getItemData(index) {\r\n    const { dataSource } = this.options;\r\n    let dataSourceItem;\r\n    if (Array.isArray(dataSource)) {\r\n      // Datasource is an array of elements\r\n      dataSourceItem = dataSource[index];\r\n    } else if (dataSource && dataSource.gallery) {\r\n      // dataSource has gallery property,\r\n      // thus it was created by Lightbox, based on\r\n      // gallery and children options\r\n\r\n      // query DOM elements\r\n      if (!dataSource.items) {\r\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\r\n      }\r\n\r\n      dataSourceItem = dataSource.items[index];\r\n    }\r\n\r\n    let itemData = dataSourceItem;\r\n\r\n    if (itemData instanceof Element) {\r\n      itemData = this._domElementToItemData(itemData);\r\n    }\r\n\r\n    // Dispatching the itemData event,\r\n    // it's a legacy verion before filters were introduced\r\n    const event = this.dispatch('itemData', {\r\n      itemData: itemData || {},\r\n      index\r\n    });\r\n\r\n    return this.applyFilters('itemData', event.itemData, index);\r\n  }\r\n\r\n  /**\r\n   * Get array of gallery DOM elements,\r\n   * based on childSelector and gallery element.\r\n   *\r\n   * @param {HTMLElement} galleryElement\r\n   */\r\n  _getGalleryDOMElements(galleryElement) {\r\n    if (this.options.children || this.options.childSelector) {\r\n      return getElementsFromOption(\r\n        this.options.children,\r\n        this.options.childSelector,\r\n        galleryElement\r\n      ) || [];\r\n    }\r\n\r\n    return [galleryElement];\r\n  }\r\n\r\n  /**\r\n   * Converts DOM element to item data object.\r\n   *\r\n   * @param {HTMLElement} element DOM element\r\n   */\r\n  // eslint-disable-next-line class-methods-use-this\r\n  _domElementToItemData(element) {\r\n    /** @type {SlideData} */\r\n    const itemData = {\r\n      element\r\n    };\r\n\r\n    // eslint-disable-next-line max-len\r\n    const linkEl = /** @type {HTMLAnchorElement} */ (element.tagName === 'A' ? element : element.querySelector('a'));\r\n\r\n    if (linkEl) {\r\n      // src comes from data-pswp-src attribute,\r\n      // if it's empty link href is used\r\n      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;\r\n\r\n      if (linkEl.dataset.pswpSrcset) {\r\n        itemData.srcset = linkEl.dataset.pswpSrcset;\r\n      }\r\n\r\n      itemData.width = parseInt(linkEl.dataset.pswpWidth, 10);\r\n      itemData.height = parseInt(linkEl.dataset.pswpHeight, 10);\r\n\r\n      // support legacy w & h properties\r\n      itemData.w = itemData.width;\r\n      itemData.h = itemData.height;\r\n\r\n      if (linkEl.dataset.pswpType) {\r\n        itemData.type = linkEl.dataset.pswpType;\r\n      }\r\n\r\n      const thumbnailEl = element.querySelector('img');\r\n\r\n      if (thumbnailEl) {\r\n        // msrc is URL to placeholder image that's displayed before large image is loaded\r\n        // by default it's displayed only for the first slide\r\n        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;\r\n        itemData.alt = thumbnailEl.getAttribute('alt');\r\n      }\r\n\r\n      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {\r\n        itemData.thumbCropped = true;\r\n      }\r\n    }\r\n\r\n    return this.applyFilters('domItemData', itemData, element, linkEl);\r\n  }\r\n}\n\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {PhotoSwipe} pswp\r\n */\r\nfunction getViewportSize(options, pswp) {\r\n  if (options.getViewportSizeFn) {\r\n    const newViewportSize = options.getViewportSizeFn(options, pswp);\r\n    if (newViewportSize) {\r\n      return newViewportSize;\r\n    }\r\n  }\r\n\r\n  return {\r\n    x: document.documentElement.clientWidth,\r\n\r\n    // TODO: height on mobile is very incosistent due to toolbar\r\n    // find a way to improve this\r\n    //\r\n    // document.documentElement.clientHeight - doesn't seem to work well\r\n    y: window.innerHeight\r\n  };\r\n}\r\n\r\n/**\r\n * Parses padding option.\r\n * Supported formats:\r\n *\r\n * // Object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // A function that returns the object\r\n * paddingFn: (viewportSize, itemData, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // Legacy variant\r\n * paddingLeft: 0,\r\n * paddingRight: 0,\r\n * paddingTop: 0,\r\n * paddingBottom: 0,\r\n *\r\n * @param {'left' | 'top' | 'bottom' | 'right'} prop\r\n * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {number} index Slide index\r\n * @returns {number}\r\n */\r\nfunction parsePaddingOption(prop, options, viewportSize, itemData, index) {\r\n  /** @type {number} */\r\n  let paddingValue;\r\n\r\n  if (options.paddingFn) {\r\n    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];\r\n  } else if (options.padding) {\r\n    paddingValue = options.padding[prop];\r\n  } else {\r\n    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1);\r\n    // @ts-expect-error\r\n    if (options[legacyPropName]) {\r\n      // @ts-expect-error\r\n      paddingValue = options[legacyPropName];\r\n    }\r\n  }\r\n\r\n  return paddingValue || 0;\r\n}\r\n\r\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {{ x?: number; y?: number }} viewportSize\r\n * @param {SlideData} itemData\r\n * @param {number} index\r\n */\r\nfunction getPanAreaSize(options, viewportSize, itemData, index) {\r\n  return {\r\n    x: viewportSize.x\r\n      - parsePaddingOption('left', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('right', options, viewportSize, itemData, index),\r\n    y: viewportSize.y\r\n      - parsePaddingOption('top', options, viewportSize, itemData, index)\r\n      - parsePaddingOption('bottom', options, viewportSize, itemData, index)\r\n  };\r\n}\n\nconst MAX_IMAGE_WIDTH = 4000;\r\n\r\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import(\"../slide/slide\").SlideData} SlideData */\r\n\r\n/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */\r\n\r\n/**\r\n * Calculates zoom levels for specific slide.\r\n * Depends on viewport size and image size.\r\n */\r\nclass ZoomLevel {\r\n  /**\r\n   * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {number} index Slide index\r\n   * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet\r\n   */\r\n  constructor(options, itemData, index, pswp) {\r\n    this.pswp = pswp;\r\n    this.options = options;\r\n    this.itemData = itemData;\r\n    this.index = index;\r\n  }\r\n\r\n  /**\r\n   * Calculate initial, secondary and maximum zoom level for the specified slide.\r\n   *\r\n   * It should be called when either image or viewport size changes.\r\n   *\r\n   * @param {number} maxWidth\r\n   * @param {number} maxHeight\r\n   * @param {{ x?: number; y?: number }} panAreaSize\r\n   */\r\n  update(maxWidth, maxHeight, panAreaSize) {\r\n    this.elementSize = {\r\n      x: maxWidth,\r\n      y: maxHeight\r\n    };\r\n\r\n    this.panAreaSize = panAreaSize;\r\n\r\n    const hRatio = this.panAreaSize.x / this.elementSize.x;\r\n    const vRatio = this.panAreaSize.y / this.elementSize.y;\r\n\r\n    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);\r\n    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);\r\n\r\n    // zoom.vFill defines zoom level of the image\r\n    // when it has 100% of viewport vertical space (height)\r\n    this.vFill = Math.min(1, vRatio);\r\n\r\n    this.initial = this._getInitial();\r\n    this.secondary = this._getSecondary();\r\n    this.max = Math.max(\r\n      this.initial,\r\n      this.secondary,\r\n      this._getMax()\r\n    );\r\n\r\n    this.min = Math.min(\r\n      this.fit,\r\n      this.initial,\r\n      this.secondary\r\n    );\r\n\r\n    if (this.pswp) {\r\n      this.pswp.dispatch('zoomLevelsUpdate', { zoomLevels: this, slideData: this.itemData });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses user-defined zoom option.\r\n   *\r\n   * @private\r\n   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)\r\n   */\r\n  _parseZoomLevelOption(optionPrefix) {\r\n    // eslint-disable-next-line max-len\r\n    const optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */ (optionPrefix + 'ZoomLevel');\r\n    const optionValue = this.options[optionName];\r\n\r\n    if (!optionValue) {\r\n      return;\r\n    }\r\n\r\n    if (typeof optionValue === 'function') {\r\n      return optionValue(this);\r\n    }\r\n\r\n    if (optionValue === 'fill') {\r\n      return this.fill;\r\n    }\r\n\r\n    if (optionValue === 'fit') {\r\n      return this.fit;\r\n    }\r\n\r\n    return Number(optionValue);\r\n  }\r\n\r\n  /**\r\n   * Get zoom level to which image will be zoomed after double-tap gesture,\r\n   * or when user clicks on zoom icon,\r\n   * or mouse-click on image itself.\r\n   * If you return 1 image will be zoomed to its original size.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getSecondary() {\r\n    let currZoomLevel = this._parseZoomLevelOption('secondary');\r\n\r\n    if (currZoomLevel) {\r\n      return currZoomLevel;\r\n    }\r\n\r\n    // 3x of \"fit\" state, but not larger than original\r\n    currZoomLevel = Math.min(1, this.fit * 3);\r\n\r\n    if (currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {\r\n      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;\r\n    }\r\n\r\n    return currZoomLevel;\r\n  }\r\n\r\n  /**\r\n   * Get initial image zoom level.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getInitial() {\r\n    return this._parseZoomLevelOption('initial') || this.fit;\r\n  }\r\n\r\n  /**\r\n   * Maximum zoom level when user zooms\r\n   * via zoom/pinch gesture,\r\n   * via cmd/ctrl-wheel or via trackpad.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\r\n  _getMax() {\r\n    const currZoomLevel = this._parseZoomLevelOption('max');\r\n\r\n    if (currZoomLevel) {\r\n      return currZoomLevel;\r\n    }\r\n\r\n    // max zoom level is x4 from \"fit state\",\r\n    // used for zoom gesture and ctrl/trackpad zoom\r\n    return Math.max(1, this.fit * 4);\r\n  }\r\n}\n\n/**\r\n * Lazy-load an image\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox\r\n * @param {number} index\r\n * @returns Image that is being decoded or false.\r\n */\r\nfunction lazyLoadData(itemData, instance, index) {\r\n  // src/slide/content/content.js\r\n  const content = instance.createContentFromData(itemData, index);\r\n\r\n  if (!content || !content.lazyLoad) {\r\n    return;\r\n  }\r\n\r\n  const { options } = instance;\r\n\r\n  // We need to know dimensions of the image to preload it,\r\n  // as it might use srcset and we need to define sizes\r\n  // @ts-expect-error should provide pswp instance?\r\n  const viewportSize = instance.viewportSize || getViewportSize(options, instance);\r\n  const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);\r\n\r\n  const zoomLevel = new ZoomLevel(options, itemData, -1);\r\n  zoomLevel.update(content.width, content.height, panAreaSize);\r\n\r\n  content.lazyLoad();\r\n  content.setDisplayedSize(\r\n    Math.ceil(content.width * zoomLevel.initial),\r\n    Math.ceil(content.height * zoomLevel.initial)\r\n  );\r\n\r\n  return content;\r\n}\r\n\r\n\r\n/**\r\n * Lazy-loads specific slide.\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * By default it loads image based on viewport size and initial zoom level.\r\n *\r\n * @param {number} index Slide index\r\n * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance\r\n */\r\nfunction lazyLoadSlide(index, instance) {\r\n  const itemData = instance.getItemData(index);\r\n\r\n  if (instance.dispatch('lazyLoadSlide', { index, itemData }).defaultPrevented) {\r\n    return;\r\n  }\r\n\r\n  return lazyLoadData(itemData, instance, index);\r\n}\n\n/**\r\n * @template T\r\n * @typedef {import(\"../types\").Type<T>} Type<T>\r\n */\r\n\r\n/** @typedef {import(\"../photoswipe\").default} PhotoSwipe */\r\n/** @typedef {import(\"../photoswipe\").PhotoSwipeOptions} PhotoSwipeOptions */\r\n/** @typedef {import(\"../photoswipe\").DataSource} DataSource */\r\n/** @typedef {import(\"../slide/content\").default} Content */\r\n/** @typedef {import(\"../core/eventable\").PhotoSwipeEventsMap} PhotoSwipeEventsMap */\r\n/** @typedef {import(\"../core/eventable\").PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */\r\n\r\n/**\r\n * @template T\r\n * @typedef {import(\"../core/eventable\").EventCallback<T>} EventCallback<T>\r\n */\r\n\r\n/**\r\n * PhotoSwipe Lightbox\r\n *\r\n * - If user has unsupported browser it falls back to default browser action (just opens URL)\r\n * - Binds click event to links that should open PhotoSwipe\r\n * - parses DOM strcture for PhotoSwipe (retrieves large image URLs and sizes)\r\n * - Initializes PhotoSwipe\r\n *\r\n *\r\n * Loader options use the same object as PhotoSwipe, and supports such options:\r\n *\r\n * gallery - Element | Element[] | NodeList | string selector for the gallery element\r\n * children - Element | Element[] | NodeList | string selector for the gallery children\r\n *\r\n */\r\nclass PhotoSwipeLightbox extends PhotoSwipeBase {\r\n  /**\r\n   * @param {PhotoSwipeOptions} options\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    /** @type {PhotoSwipeOptions} */\r\n    this.options = options || {};\r\n    this._uid = 0;\r\n  }\r\n\r\n  /**\r\n   * Initialize lightbox, should be called only once.\r\n   * It's not included in the main constructor, so you may bind events before it.\r\n   */\r\n  init() {\r\n    this.onThumbnailsClick = this.onThumbnailsClick.bind(this);\r\n\r\n    // Bind click events to each gallery\r\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector)\r\n      .forEach((galleryElement) => {\r\n        galleryElement.addEventListener('click', this.onThumbnailsClick, false);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @param {MouseEvent} e\r\n   */\r\n  onThumbnailsClick(e) {\r\n    // Exit and allow default browser action if:\r\n    if (specialKeyUsed(e) // ... if clicked with a special key (ctrl/cmd...)\r\n        || window.pswp // ... if PhotoSwipe is already open\r\n        || window.navigator.onLine === false) { // ... if offline\r\n      return;\r\n    }\r\n\r\n    // If both clientX and clientY are 0 or not defined,\r\n    // the event is likely triggered by keyboard,\r\n    // so we do not pass the initialPoint\r\n    //\r\n    // Note that some screen readers emulate the mouse position,\r\n    // so it's not ideal way to detect them.\r\n    //\r\n    let initialPoint = { x: e.clientX, y: e.clientY };\r\n\r\n    if (!initialPoint.x && !initialPoint.y) {\r\n      initialPoint = null;\r\n    }\r\n\r\n    let clickedIndex = this.getClickedIndex(e);\r\n    clickedIndex = this.applyFilters('clickedIndex', clickedIndex, e, this);\r\n    const dataSource = {\r\n      gallery: /** @type {HTMLElement} */ (e.currentTarget)\r\n    };\r\n\r\n    if (clickedIndex >= 0) {\r\n      e.preventDefault();\r\n      this.loadAndOpen(clickedIndex, dataSource, initialPoint);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get index of gallery item that was clicked.\r\n   *\r\n   * @param {MouseEvent} e click event\r\n   */\r\n  getClickedIndex(e) {\r\n    // legacy option\r\n    if (this.options.getClickedIndexFn) {\r\n      return this.options.getClickedIndexFn.call(this, e);\r\n    }\r\n\r\n    const clickedTarget = /** @type {HTMLElement} */ (e.target);\r\n    const childElements = getElementsFromOption(\r\n      this.options.children,\r\n      this.options.childSelector,\r\n      /** @type {HTMLElement} */ (e.currentTarget)\r\n    );\r\n    const clickedChildIndex = childElements.findIndex(\r\n      child => child === clickedTarget || child.contains(clickedTarget)\r\n    );\r\n\r\n    if (clickedChildIndex !== -1) {\r\n      return clickedChildIndex;\r\n    } else if (this.options.children || this.options.childSelector) {\r\n      // click wasn't on a child element\r\n      return -1;\r\n    }\r\n\r\n    // There is only one item (which is the gallery)\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Load and open PhotoSwipe\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource=} dataSource\r\n   * @param {{ x?: number; y?: number }} [initialPoint]\r\n   */\r\n  loadAndOpen(index, dataSource, initialPoint) {\r\n    // Check if the gallery is already open\r\n    if (window.pswp) {\r\n      return false;\r\n    }\r\n\r\n    // set initial index\r\n    this.options.index = index;\r\n\r\n    // define options for PhotoSwipe constructor\r\n    this.options.initialPointerPos = initialPoint;\r\n\r\n    this.shouldOpen = true;\r\n    this.preload(index, dataSource);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Load the main module and the slide content by index\r\n   *\r\n   * @param {number} index\r\n   * @param {DataSource=} dataSource\r\n   */\r\n  preload(index, dataSource) {\r\n    const { options } = this;\r\n\r\n    if (dataSource) {\r\n      options.dataSource = dataSource;\r\n    }\r\n\r\n    // Add the main module\r\n    /** @type {Promise<Type<PhotoSwipe>>[]} */\r\n    const promiseArray = [];\r\n\r\n    const pswpModuleType = typeof options.pswpModule;\r\n    if (isPswpClass(options.pswpModule)) {\r\n      promiseArray.push(Promise.resolve(/** @type {Type<PhotoSwipe>} */ (options.pswpModule)));\r\n    } else if (pswpModuleType === 'string') {\r\n      throw new Error('pswpModule as string is no longer supported');\r\n    } else if (pswpModuleType === 'function') {\r\n      promiseArray.push(/** @type {() => Promise<Type<PhotoSwipe>>} */ (options.pswpModule)());\r\n    } else {\r\n      throw new Error('pswpModule is not valid');\r\n    }\r\n\r\n    // Add custom-defined promise, if any\r\n    if (typeof options.openPromise === 'function') {\r\n      // allow developers to perform some task before opening\r\n      promiseArray.push(options.openPromise());\r\n    }\r\n\r\n    if (options.preloadFirstSlide !== false && index >= 0) {\r\n      this._preloadedContent = lazyLoadSlide(index, this);\r\n    }\r\n\r\n    // Wait till all promises resolve and open PhotoSwipe\r\n    const uid = ++this._uid;\r\n    Promise.all(promiseArray).then((iterableModules) => {\r\n      if (this.shouldOpen) {\r\n        const mainModule = iterableModules[0];\r\n        this._openPhotoswipe(mainModule, uid);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} module\r\n   * @param {number} uid\r\n   */\r\n  _openPhotoswipe(module, uid) {\r\n    // Cancel opening if UID doesn't match the current one\r\n    // (if user clicked on another gallery item before current was loaded).\r\n    //\r\n    // Or if shouldOpen flag is set to false\r\n    // (developer may modify it via public API)\r\n    if (uid !== this._uid && this.shouldOpen) {\r\n      return;\r\n    }\r\n\r\n    this.shouldOpen = false;\r\n\r\n    // PhotoSwipe is already open\r\n    if (window.pswp) {\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Pass data to PhotoSwipe and open init\r\n     *\r\n     * @type {PhotoSwipe}\r\n     */\r\n    const pswp = typeof module === 'object'\r\n        ? new module.default(this.options) // eslint-disable-line\r\n        : new module(this.options); // eslint-disable-line\r\n\r\n    this.pswp = pswp;\r\n    window.pswp = pswp;\r\n\r\n    // map listeners from Lightbox to PhotoSwipe Core\r\n    /** @type {(keyof PhotoSwipeEventsMap)[]} */\r\n    (Object.keys(this._listeners)).forEach((name) => {\r\n      this._listeners[name].forEach((fn) => {\r\n        pswp.on(name, /** @type {EventCallback<typeof name>} */(fn));\r\n      });\r\n    });\r\n\r\n    // same with filters\r\n    /** @type {(keyof PhotoSwipeFiltersMap)[]} */\r\n    (Object.keys(this._filters)).forEach((name) => {\r\n      this._filters[name].forEach((filter) => {\r\n        pswp.addFilter(name, filter.fn, filter.priority);\r\n      });\r\n    });\r\n\r\n    if (this._preloadedContent) {\r\n      pswp.contentLoader.addToCache(this._preloadedContent);\r\n      this._preloadedContent = null;\r\n    }\r\n\r\n    pswp.on('destroy', () => {\r\n      // clean up public variables\r\n      this.pswp = null;\r\n      window.pswp = null;\r\n    });\r\n\r\n    pswp.init();\r\n  }\r\n\r\n  /**\r\n   * Unbinds all events, closes PhotoSwipe if it's open.\r\n   */\r\n  destroy() {\r\n    if (this.pswp) {\r\n      this.pswp.destroy();\r\n    }\r\n\r\n    this.shouldOpen = false;\r\n    this._listeners = null;\r\n\r\n    getElementsFromOption(this.options.gallery, this.options.gallerySelector)\r\n      .forEach((galleryElement) => {\r\n        galleryElement.removeEventListener('click', this.onThumbnailsClick, false);\r\n      });\r\n  }\r\n}\n\nexport { PhotoSwipeLightbox as default };\n"]},"metadata":{},"sourceType":"module"}